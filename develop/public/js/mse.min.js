"use strict";

function mse(video, src, resizeFunc) {

    this.debug = 0;
    this.heartbeat = 0;
    this.streamingStarted = false;
    this.queue = [];
    this.ws = null;

    this.element = video;
    this.src = src;

    this.mediaSource = new MediaSource();

    this.sourceBuffer;
    this.mimeCodec;

    var _this = this;

    if (!Uint8Array.prototype.slice) {
        Object.defineProperty(Uint8Array.prototype, 'slice', {
            value: function (begin, end) {
                return new Uint8Array(Array.prototype.slice.call(this, begin, end));
            }
        });
    }

    this.pushPacket = function (arr) {
        var view = new Uint8Array(arr);
        if (_this.debug) {
            console.log("got", arr.byteLength, "bytes.  Values=", view[0], view[1], view[2], view[3], view[4]);
        }
        const data = arr;
        if (!_this.streamingStarted) {
            try {
                _this.sourceBuffer.appendBuffer(data);
                _this.streamingStarted = true;

                /*
                *  < 0.5 : 0.2x
                *  0.51 ~ 0.8 : 0.2x
                *  0.81 ~ 1.0 :  normal
                *  1.0 ~ 1.5 :  1.5x
                *  1.51 ~ 3.0 : 2x
                *  > 3.0 : seek to last
                * */

                if (_this.element.buffered.length > 0) {
                    const threshold = _this.element.buffered.end(0) - _this.element.currentTime;

                    _this.element.controls = false;

                    if (threshold < 0.4) {
                        _this.element.playbackRate = 0.2;
                        //console.log(threshold, "0.2x")
                    } else if (threshold >= 0.4 && threshold <= 1.0) {
                        _this.element.playbackRate = 1;
                        //console.log(threshold, "1x")
                    } else if (threshold > 1.0 && threshold <= 2.0) {
                        _this.element.playbackRate = 1.5;
                        //console.log(threshold, "1.5x")
                    } else if (threshold > 2.0 && threshold <= 3.0) {
                        _this.element.playbackRate = 2;
                        //console.log(threshold, "2x")
                    } else {
                        //console.log("seek from ", _this.element.currentTime, " to ", _this.element.buffered.end(0) - 0.5);
                        _this.element.currentTime = _this.element.buffered.end(0) - 0.5;
                        _this.element.playbackRate = 1;
                    }
                    _this.element.controls = true;
                }
            } catch (e) {
                _this.close();
                _this.element.setAttribute('error', 'true');
                _this.debug && console.error(e);
            }
            return;
        }
        _this.queue.push(data);

        if (_this.debug) {
            console.log("queue push:", _this.queue.length);
        }
        if (!_this.sourceBuffer.updating) {
            _this.loadPacket();
        }
    }

    this.loadPacket = function () {
        _this.heartbeat = 0;

        if (!_this.sourceBuffer.updating) {
            if (_this.queue.length > 0) {
                const inp = _this.queue.shift();
                if (_this.debug) {
                    console.log("queue PULL:", _this.queue.length);
                }
                var view = new Uint8Array(inp);
                if (_this.debug) {
                    console.log("writing buffer with", view[0], view[1], view[2], view[3], view[4]);
                }
                try {
                    _this.sourceBuffer.appendBuffer(inp);
                    _this.streamingStarted = true;
                } catch (e) {
                    _this.close();
                    _this.element.setAttribute('error', 'true');
                    _this.debug && console.error(e);
                }
            } else {
                _this.streamingStarted = false;
            }
        }
    }

    this.opened = function () {
        _this.ws = new WebSocket(_this.src);
        _this.ws.binaryType = "arraybuffer";
        _this.ws.onopen = function (event) {
            if (_this.debug) {
                console.log(`Connect ${_this.src}`);
            }
        }
        _this.ws.onmessage = function (event) {
            var data = new Uint8Array(event.data);
            if (data[0] == 9) {
                const decoded_arr = data.slice(1);
                if (window.TextDecoder) {
                    _this.mimeCodec = new TextDecoder("utf-8").decode(decoded_arr);
                } else {
                    _this.mimeCodec = _this.Utf8ArrayToStr(decoded_arr);
                }
                if (_this.debug) {
                    console.log('first packet with codec data: ' + _this.mimeCodec);
                }
                _this.sourceBuffer = _this.mediaSource.addSourceBuffer('video/mp4; codecs="' + _this.mimeCodec + '"');
                _this.sourceBuffer.mode = "segments"
                _this.sourceBuffer.addEventListener("updateend", _this.loadPacket);

                if (resizeFunc) resizeFunc();
            } else {
                _this.pushPacket(event.data);
            }
        };
        _this.ws.onclose = () => {
            _this.debug && console.log(`${_this.src} Closed`);
        };
    }

    this.Utf8ArrayToStr = function (array) {
        var out, i, len, c;
        var char2, char3;
        out = "";
        len = array.length;
        i = 0;
        while (i < len) {
            c = array[i++];
            switch (c >> 4) {
                case 7:
                    out += String.fromCharCode(c);
                    break;
                case 13:
                    char2 = array[i++];
                    out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
                    break;
                case 14:
                    char2 = array[i++];
                    char3 = array[i++];
                    out += String.fromCharCode(((c & 0x0F) << 12) |
                        ((char2 & 0x3F) << 6) |
                        ((char3 & 0x3F) << 0));
                    break;
            }
        }
        return out;
    }

    this.startup = function () {
        _this.mediaSource.addEventListener('sourceopen', _this.opened, false);
        _this.element.src = window.URL.createObjectURL(_this.mediaSource);
    }

    this.close = function () {
        _this.mediaSource.removeEventListener('sourceopen', _this.opened, false);
        //_this.element.src = '';
        _this.ws.close();
    }
}